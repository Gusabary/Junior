# Homework

## Homework 1

1. huge page 可以看成是将下一级页表的所有 page 合并成了一个 page。对于 32 位机器来说，PTE 为 4B，所以一个页表页中有 1024 个 PTE，那么这 1024 个 page 合并起来就是 4M；而对于 64 位机器来说，PTE 为 8B，所以一个页表页中只有 512 个 PTE，一个 huge page 的大小也就是 2M。

2. 用时间换空间，多级页表的设计可以有效避免对很多没有用到的页的映射。

   一个四级页表页 spatial overhead 最大值为 4088B，即整个页表页中只有一个 PTE 被用到。

3. PTE 中的第 0 位为 valid 位，表示该项是否有效。

4. 好处：减少页表级数，提升遍历页表的效率。当应用程序一次申请多个页的时候可以分配给它一张大页。

   弊端：粒度比较粗，使用时容易造成空间上的 overhead。当应用程序逐渐释放之前申请的内存时，整张大页必须要等该页中全部内存都被释放才能回收。

5. 两个 ttbr 的好处在于应用程序和内核可以拥有不同的地址空间，如果不用这个机制，attribution-based isolation 确实可以起到一定的隔离作用，但是因为是作用在 PTE 上，所以粒度最小也就是一个页的大小。如果在某一个页中，部分内存是应用程序可访问的，而另一部分是应用程序不可访问的，attribution-based isolation 就很难解决这一点。

6. 因为不同进程的同一个虚拟地址可能对应不同的物理地址，所以进程切换的时候 TLB 需要刷新。而用户态切换到内核态的时候不需要刷新，因为它们用的是不同的 ttbr。

7. 将 PTE 中的 AP 设为 read-only，当试图进行写操作时会有异常，此时在 handler 中再将其设为 read/write。

## Homework 2

1. 只有当前线程被复制到子进程中。

   如果在 fork 前某个线程拿了锁，而 fork 之后因为只有当前线程，所以被另外一个线程持有的锁就不会被释放从而造成死锁。

   一个可能的原因是 fork 复制用户空间的虚存，而和线程相关的信息保存在内核空间中。

2. 因为即使采用 COW，fork 仍然需要先拷贝页表，而 vfork 连页表也不需要拷贝。

   使用更多的 huge page，这样在拷贝页表的时候可以降低拷贝的数量。

3. 因为跨进程的线程切换需要切换地址空间，这本身就是一个开销不小的操作，并且还可能导致 TLB 刷新。

4. 因为内核的虚存空间在高地址并且使用的 ttbr 也和用户态不一样，切换页表的时候不会对其造成影响。

5. 使用多进程 + 协程的方法可以利用多核资源，尤其适合需要频繁进行逻辑流调度的程序。

6. 对于一般的请求来说，创建一个新的线程，这样可以快速切换以满足低时延的要求；

   对于代码处理请求，创建一个新的进程，这样可以避免它访问到其他进程的虚存。

   TCB 中需要保存线程状态以及寄存器信息，PCB 中还需要保存进程的状态和虚存信息。

   在发生线程的上下文切换时，保存上下文、切换内核栈、恢复上下文即可；而在发生进程的上下文切换时，还需要切换页表。

##### Last-modified date: 2020.4.3, 11 a.m.